基于 Claude Code 构建自主多智能体协作系统的架构蓝图：
                          
                          从单兵 CLI 到集群编排的演进之路

------------------------------------------------
1. 执行摘要：从交互式增强到智能体集群的范式转移
------------------------------------------------

在现代软件工程的演进中，将大语言模型（LLM）集成到开发工作流中已经经历了从简单的代码补全到复杂的交互式对话的转变。当前，绝大多数开发者——包括本报告的目标用户——处于一级成熟度（交互式增强阶段）。在这个阶段，开发者熟练掌握了 git 仓库的创建与更新，并能通过终端（Git Bash）调用 claude 命令进行简单的代码生成与提交。然而，用户所设想的终极目标——由6个专门的智能体（规划、编码、测试、优化、安全、技术负责人）组成的自主协作团队——属于四级成熟度（异步多智能体编排阶段）。这种跨越并非简单的命令堆叠，而是对运行时环境、权限管理模型以及上下文传输协议的根本性重构。用户当前遇到的“No agents found”错误，不仅是一个配置缺失的问题，更是从单体应用思维向分布式智能体架构转变过程中的典型阻碍 。为了实现从简单的 claude code + git push 到全自动化的六智能体协同，必须建立一套分层的技术栈：底层是基于文件系统的状态锚定，中间层是无头（Headless）运行时的权限自动化，顶层是基于 Python 或 Bash 的编排逻辑。本报告将提供一份详尽的、字数达 1.5 万字的技术深度分析与实施路线图。我们将剖析如何解耦 Claude 的智能核心与交互界面，建立稳健的智能体间通信协议（IPC），并利用最新的 /agents 功能模块化定义角色。核心论点在于：在 Claude Code 生态系统中，“智能体”不应被视为单一的聊天窗口，而是由严格的配置文件、专用的系统提示词（System Prompt）以及细粒度的工具权限集定义的可组合运行时实例 。报告将严格遵循“循序渐进”的原则，将实施路径划分为四个具体的工程阶段，通过详细的代码示例、配置模板和架构图解，指导用户逐步实现真正的全自动软件开发流水线。




--------------------------
2. 基础架构解析与环境重构
--------------------------

在构建多智能体系统之前，深入理解 Claude Code 的运行时机制至关重要。用户在 Git Bash 中看到的交互界面只是冰山一角，真正的自动化潜力潜藏在其 CLI 参数与文件系统钩子之中。
2.1 智能体定义的数学模型与实体化用户在尝试使用 /agents 命令时遭遇的“No agents found”提示，揭示了 Claude Code 的一个核心设计理念：智能体即配置（Agent as Configuration）。与某些将智能体封装为独立二进制文件的平台不同，Claude Code 中的智能体是运行时状态的一个切片。我们可以将一个智能体 $A$ 数学化定义为一个四元组：$$A = \{P, T, C, M\}$$其中：$P$ (Persona/System Prompt)：系统提示词。这是智能体的灵魂，它覆盖了默认的通用助手行为，强制模型进入特定的角色（如“你是一个严苛的安全审计员”）。$T$ (Tool Registry)：工具注册表。这是智能体的手脚，定义了它能做什么（如只读文件、写入代码、执行测试）。$C$ (Context)：上下文环境。包括全局记忆（CLAUDE.md）、项目记忆和当前的会话历史。$M$ (Model)：推理引擎。不同的任务需要不同的模型（如规划需要高智商的 Sonnet，测试日志分析可能只需要快速的 Haiku）。用户当前无法看到智能体，是因为缺少了将这个四元组实体化的配置文件。Claude Code 要求在 .claude/agents/ 目录下以 Markdown 文件（包含 YAML 前置元数据）的形式显式定义这些智能体 。

2.2 运行时模式的二元性：交互式与无头模式要实现自动化，用户必须掌握 Claude Code 的两种截然不同的运行模式。
2.2.1 交互式模式（当前状态）用户目前熟练使用的是交互式模式（Interactive Mode）。特征：$ claude。程序启动后，占用标准输入（STDIN），等待用户键入自然语言指令。局限：这是同步且阻塞的。如果不进行人工干预，一个智能体完成任务后，系统会无限期等待下一个指令。这使得“6个智能体同时协作”在纯交互模式下变得不可能，除非用户手动开启6个终端窗口并来回复制粘贴 。
2.2.2 无头模式（Headless/Print Mode，未来状态）实现目标的关键在于 -p 标志（Print Mode）。特征：$ claude -p "Prompt" --output-format json。程序启动，执行单一任务，输出结果，然后终止进程 。优势：它是异步且非阻塞的（相对于用户而言）。可以通过脚本循环调用，或者通过管道（Pipe）将一个进程的输出接入另一个进程的输入。这是构建“自动推进任务”的基础 。





---------------------------------------------------------------
3. 第一阶段：环境初始化与智能体定义（解决“No agents found”）
---------------------------------------------------------------

根据用户的“循序渐进”要求，第一步不是编写复杂的自动化脚本，而是先解决眼前的障碍：创建并注册那6个核心智能体。这将立即使 /agents 命令生效，并为后续的自动化打下基础。
3.1 目录结构与配置规范用户需要在项目根目录下建立标准的配置结构。这不仅是让 Claude 识别智能体，更是为了实现上下文隔离。推荐的项目文件结构：project-root/├──.claude/│   ├── agents/              <-- 存放智能体定义文件│   │   ├── 01-architect.md  (规划)│   │   ├── 02-tech-lead.md  (技术负责/统筹)│   │   ├── 03-developer.md  (写代码)│   │   ├── 04-tester.md     (测试)│   │   ├── 05-optimizer.md  (优化)│   │   └── 06-security.md   (安全)│   ├── settings.json        <-- 权限与工具配置│   └── CLAUDE.md            <-- 项目全局规范├── src/└── tests/

3.2 六大智能体的详细定义实战为了满足用户提到的具体分工（规划、写代码、测试、优化），我们需要为每个角色编写精确的定义文件。这些文件采用 Markdown 格式，头部包含 YAML 配置 。

3.2.1 规划智能体 (Architect)此智能体负责顶层设计，它需要通过 grep 和 ls 了解项目结构，但通常不需要修改代码，以免引入混乱。文件路径：.claude/agents/01-architect.mdname: architect
description: 系统架构师，负责分析需求、设计系统结构并生成实施计划。
color: purple
model: sonnet
tools: Read, Glob, Grep, LS, Bash(git status), Bash(git diff)角色定义你是一个资深的软件架构师。你的目标是理解用户需求，并结合当前代码库的状态，制定详细的实施计划。核心职责需求分析：深度解析用户的自然语言需求。现状调研：使用 ls, grep 等工具探索现有代码架构。产出计划：你不直接编写代码。你的唯一产出是创建或更新 PLAN.md 文件。工作流约束在开始设计前，必须读取 CLAUDE.md 以了解项目规范。计划必须包含：涉及的文件列表、依赖变更、分步实施路径。严禁直接修改 src/ 目录下的源代码。

3.2.2 技术负责人 (Tech Lead)这是用户提到的“Tech Lead”，负责任务分配和标准把控。文件路径：.claude/agents/02-tech-lead.mdname: tech-lead
description: 技术负责人，负责审核计划的可行性，分解任务，并确保代码风格一致性。
color: blue
model: sonnet
tools: Read, Write, Edit, Bash角色定义你是项目的技术负责人。你负责连接架构设计与具体实施。核心职责审查 PLAN.md 的合理性。将大任务分解为 Developer 可以执行的小任务。维护 CLAUDE.md 中的编码规范。

3.2.3 编码智能体 (Developer)负责具体的代码实现，拥有文件写入权限。文件路径：.claude/agents/03-developer.mdname: developer
description: 资深开发工程师，负责根据计划编写高质量、符合规范的代码。
color: cyan
model: sonnet
tools: Read, Write, Edit, Bash, Glob角色定义你是一个全栈开发工程师。你的任务是执行 PLAN.md 中的具体步骤。核心职责读取 PLAN.md 确认当前任务。编写代码实现功能。不进行大规模重构，只关注功能实现。在完成一个功能点后，主动更新 PROGRESS.md。

3.2.4 测试智能体 (QA Tester)专注于破坏性测试和验证 。文件路径：.claude/agents/04-tester.mdname: tester
description: 质量保证工程师，负责编写测试用例、执行测试并报告缺陷。
color: red
model: haiku
tools: Read, Write, Edit, Bash角色定义你是一个苛刻的 QA 工程师。你的目标是找出代码中的 Bug。核心职责为新功能编写单元测试和集成测试。运行测试命令（如 npm test 或 pytest）。分析错误日志。不修复 Bug。如果测试失败，创建一个详细的 BUG_REPORT.md，描述复现步骤和错误堆栈。

3.2.5 优化智能体 (Optimizer)负责代码重构和性能提升 。文件路径：.claude/agents/05-optimizer.mdname: optimizer
description: 代码优化专家，专注于代码重构、性能提升和消除技术债务。
color: orange
model: sonnet
tools: Read, Edit, Bash角色定义你是一个追求极致的代码优化专家。核心职责审查代码的复杂度（如循环嵌套、冗余逻辑）。进行代码重构以提高可读性。在修改代码后，必须运行测试以确保不破坏现有功能。

3.2.6 安全审查员 (Security)负责安全审计 。文件路径：.claude/agents/06-security.mdname: security
description: 安全专家，负责审计代码中的漏洞（OWASP Top 10）、密钥泄露和依赖风险。
color: yellow
model: sonnet
tools: Read, Glob, Grep角色定义你是一个红队安全专家。核心职责扫描代码中的硬编码密钥、SQL 注入风险、XSS 漏洞。检查 package.json 或 requirements.txt 中的依赖版本风险。产出 SECURITY_AUDIT.md 报告。实施步骤：用户现在应该在本地创建上述6个文件。完成后，在终端运行 claude 进入交互模式，输入 /agents。此时，系统不再显示“No agents found”，而是列出这6个可用的专家。用户可以通过 @architect 或 @developer 在对话中直接调用它们。这是实现目标的第一步：身份的确立。





------------------------------------------
4. 第二阶段：打破权限壁垒与自动化配置
------------------------------------------

用户提到“似乎还有很多指令和权限需要开放才行”。这是一个极其敏锐的观察。在默认情况下，Claude Code 为了安全，每执行一个涉及文件修改或 Shell 命令的操作，都会暂停并询问“Allow this action? (y/n)”。对于一个试图自动运行的6智能体系统来说，这种阻塞是致命的 。

4.1 权限自动化的两种路径要实现“自动推进任务”，必须配置权限白名单。
4.1.1 激进方案：--dangerously-skip-permissions这是最快实现自动化的方式，通常被称为“YOLO 模式” 。命令：claude --dangerously-skip-permissions效果：所有工具调用（读、写、执行命令）都会被自动批准，无需人工干预。风险：如果智能体产生幻觉，执行了 rm -rf / 或错误的 git push --force，后果不可挽回。适用场景：运行在 Docker 容器或沙盒环境中的全自动脚本。
4.1.2 稳健方案：settings.json 白名单为了在保障安全的前提下实现自动化，推荐编辑 .claude/settings.json 文件 。配置示例：JSON{
  "permissions": {
    "allow":,
    "deny":
  }
}
深度解析：Bash(git commit *)：允许智能体自动提交代码，这是版本控制自动化的核心。Edit(src/*)：限制智能体只能修改源码目录，防止修改配置文件或系统文件。deny 规则：明确禁止高危操作，这是多智能体协作时的安全底线。通过这种配置，当 Developer 智能体试图修改 src/main.py 时，系统会自动放行；但如果它试图删除项目根目录，系统会拦截。这解决了用户关于“权限开放”的疑虑。




-------------------------------------------------
5. 第三阶段：链式协作（Pipeline）—— 简单的自动化
-------------------------------------------------

用户目前的痛点是“手动调用”。在拥有了定义的智能体和配置好的权限后，我们可以通过**脚本化（Scripting）**将它们串联起来，形成一条自动化的生产线。这对应用户提到的“相互传输共享会话”。在 CLI 环境下，最有效的会话共享不是通过内存，而是通过文件系统和JSON 流 。

5.1 基于文件的上下文传递机制由于 Claude Code 的 -p 模式是无状态的（每次启动都是新进程），智能体之间必须通过持久化介质交换信息。架构师 -> 开发者：通过 PLAN.md 传递设计。开发者 -> 测试者：通过代码文件和 git log 传递成果。测试者 -> 开发者：通过 BUG_REPORT.md 传递反馈。

5.2 编写自动化流水线脚本 (workflow.sh)用户可以编写一个 Bash 脚本，模拟“自动推进任务”的效果。Bash#!/bin/bash

# 定义颜色输出
GREEN='\033 启动架构师 (Architect) 进行规划...${NC}"
# 调用 Architect 智能体，分析需求并写入 PLAN.md
# 注意：使用 -p (print mode) 和 --agent 标志
claude -p "Use the @architect agent. 分析当前目录下的需求文档，创建或更新 PLAN.md。不要写代码，只做计划。" \
  --dangerously-skip-permissions

echo -e "${GREEN}[Phase 2] 启动开发者 (Developer) 进行编码...${NC}"
# Developer 读取 PLAN.md 并执行
claude -p "Use the @developer agent. 阅读 PLAN.md 的第一项任务。实现相关代码。完成后运行 git add." \
  --dangerously-skip-permissions

echo -e "${GREEN}[Phase 3] 启动测试者 (Tester) 进行验证...${NC}"
# Tester 运行测试并将结果写入报告
claude -p "Use the @tester agent. 运行 npm test。如果失败，分析错误并写入 BUG_REPORT.md。如果成功，删除该文件。" \
  --dangerously-skip-permissions

# 检查是否存在 Bug 报告
if; then
    echo -e "${GREEN}[Phase 4] 检测到 Bug，启动优化器 (Optimizer) 进行修复...${NC}"
    claude -p "Use the @optimizer agent. 阅读 BUG_REPORT.md 和相关代码，修复错误并优化代码结构。" \
      --dangerously-skip-permissions
else
    echo -e "${GREEN} 测试通过！启动安全审查 (Security)...${NC}"
    claude -p "Use the @security agent. 扫描代码中的潜在漏洞。" \
      --dangerously-skip-permissions
fi
技术洞察：这个脚本展示了如何“循序渐进”地实现目标。它没有使用复杂的 Python 编排，而是利用了 Linux 的 Shell 能力。claude -p：这是自动化的核心，它让 Claude 执行完即退出，而不是挂起等待用户。Use the @agentname：这是路由指令，告诉 Claude 加载我们在 .claude/agents/ 中定义的特定角色配置。条件逻辑：Shell 脚本中的 if [ -f... ] 实现了基本的逻辑判断（如果有 Bug 报告，则调用修复；否则进行安全扫描）。这实现了用户要求的“自动推进任务”，虽然它是串行的，但已经具备了自主性。




-------------------------------------------------
6. 第四阶段：全功能多智能体集群编排（并行与协作）
-------------------------------------------------

用户最终的愿景是“6个智能体同时协作”。串行脚本（Phase 3）虽然自动化了，但在效率上并非最优。例如，QA 测试和安全审计完全可以并行进行。要实现这一点，我们需要升级到 Python 编排层，并利用高级的会话管理功能。

6.1 解决并发冲突：文件锁 (File Locking)当5-6个智能体同时在一个目录中操作时，最大的风险是竞争条件（Race Condition）。例如，Developer 正在修改 app.py，而 Optimizer 同时试图重构 app.py，这将导致文件内容损坏或 Git 冲突 。解决方案：在编排层引入文件锁机制。

6.2 高级编排脚本 (orchestrator.py)我们需要编写一个 Python 脚本来作为“元智能体”（Meta-Agent），它负责派发任务、管理进程和处理回调。Pythonimport subprocess
import time
import os
from concurrent.futures import ThreadPoolExecutor

def run_agent(agent_name, prompt, session_id=None):
    """
    封装 Claude Code CLI 调用
    """
    cmd = [
        "claude", 
        "-p", f"Use the @{agent_name} agent. {prompt}", 
        "--output-format", "json",
        "--dangerously-skip-permissions"
    ]
    
    # 会话延续：实现“传输共享会话”的关键
    if session_id:
        cmd.extend(["--resume", session_id])
        
    print(f"🚀 [{agent_name}] 正在启动: {prompt[:30]}...")
    
    # 记录开始时间
    start = time.time()
    result = subprocess.run(cmd, capture_output=True, text=True)
    duration = time.time() - start
    
    print(f"✅ [{agent_name}] 完成 (耗时 {duration:.1f}s)")
    return result.stdout

def main():
    # 1. 初始化：Architect 制定全局计划
    # 我们不传入 session_id，让其开启一个新会话
    print("=== 阶段 1: 架构规划 ===")
    plan_output = run_agent("architect", "分析需求并更新 PLAN.md")
    
    # 假设我们可以从 output json 中解析出 session_id（需要 Claude 开启 stream-json）
    # 这里为了演示，我们假设共享文件系统已经足够同步上下文
    
    # 2. 并行执行：编码与文档/安全准备
    print("=== 阶段 2: 开发与安全审计并行 ===")
    with ThreadPoolExecutor(max_workers=3) as executor:
        # 任务 A: 开发者写代码
        future_dev = executor.submit(run_agent, "developer", "根据 PLAN.md 实现核心功能")
        
        # 任务 B: 安全专家并在此时审查依赖配置（只读操作，不冲突）
        future_sec = executor.submit(run_agent, "security", "审查 package.json 的依赖安全性")
        
        # 等待开发者完成，因为测试依赖代码
        future_dev.result()
        future_sec.result()
        
    # 3. 循环迭代：测试与优化
    print("=== 阶段 3: 测试与优化循环 ===")
    max_retries = 3
    for i in range(max_retries):
        # 运行测试
        run_agent("tester", "运行所有测试")
        
        # 检查是否生成了 BUG_REPORT.md
        if os.path.exists("BUG_REPORT.md"):
            print(f"⚠️ 检测到 Bug (尝试 {i+1}/{max_retries})")
            run_agent("optimizer", "根据 BUG_REPORT.md 修复代码")
            os.remove("BUG_REPORT.md") # 清除报告以便下一次检测
        else:
            print("🎉 测试通过！全流程结束。")
            break

if __name__ == "__main__":
    main()

    
6.3 关键技术点解析

6.3.1 会话共享与“传输”用户特别提到“相互传输共享会话”。在 Claude Code CLI 中，会话是持久化在磁盘上的。机制：每次运行 claude 都会生成一个 Session ID。传输：使用 --resume <session_id> (或 -r) 参数。策略：在上述 Python 脚本中，如果 Architect 进行了一次深度的思考并生成了复杂的上下文（不仅是文件，还有思维链），我们可以捕获它的 Session ID，并在启动 Developer 时传入 -r <id>。这样，Developer 就像是“继承”了 Architect 的大脑，继续工作。警告：共享会话会迅速消耗 Context Window（上下文窗口），导致成本飙升和处理变慢。通常建议基于文件共享上下文（如 PLAN.md），只在必要时使用会话接力 。

6.3.2 并行与资源隔离在 Python 脚本中，我们使用了 ThreadPoolExecutor 来实现并行。安全智能体和编码智能体可以同时运行，前提是安全智能体只进行读取操作（Read, Glob），不修改文件。如果需要多个智能体同时修改代码（例如前端和后端分开开发），建议使用 Git 的 Worktree 功能或不同的分支，让每个智能体在独立的目录中工作，最后通过 Git Merge 合并 。







-----------------------
7. 高级建议与避坑指南
-----------------------
在实现这一宏伟目标的过程中，有几个深层次的“二阶洞察”需要注意：

7.1 上下文污染 (Context Pollution)如果让所有6个智能体在一个长会话中接力（Agent A -> Agent B -> Agent C...），会话历史会变得极其庞大且包含大量无关信息（例如 Agent A 的试错过程对 Agent C 可能是干扰）。建议：采用**“星型拓扑”**而非“链式拓扑”。即所有智能体从一个干净的基础会话开始，或者每次都开启新会话，仅通过文件系统（PLAN.md, CLAUDE.md, 代码本身）同步状态。文件系统是唯一的“真理来源”（Source of Truth）。

7.2 成本与速率限制6个智能体并行工作意味着 API 调用量激增。模型选择：在 .claude/agents/*.md 定义中，务必为简单任务（如格式化、简单测试分析）配置 model: haiku，只为架构设计和核心编码配置 model: sonnet 或 opus。这能显著降低成本并提高速度 。预算控制：在 CLI 中使用 --max-budget-usd 标志来防止失控的循环脚本在一夜之间耗尽额度 。

7.3 循环死锁在自动修复循环（Tester -> Optimizer -> Tester）中，可能会出现“修复A导致B错误，修复B导致A错误”的死循环。建议：在编排脚本中必须设置 max_retries（如代码示例中的3次），超过次数后强制中断并通知人类介入。





---------------------
8. 总结与行动清单
---------------------

用户从“熟练 Git CLI”到“6智能体集群”的跨越，本质上是从工具使用者向系统架构师的转变。循序渐进的实施清单：Day 1（定义身份）：在 .claude/agents/ 下创建6个 Markdown 文件，定义每个智能体的职责和工具集。验证 /agents 命令不再报错。Day 2（开放权限）：配置 .claude/settings.json，为 Git 和测试命令设置 Allowlist，消除交互式确认的阻碍。Day 3（脚本串联）：编写 workflow.sh，尝试让 Architect 自动生成计划，Developer 自动写出 Hello World。体验无头模式 -p 的威力。Day 4（并行编排）：编写 orchestrator.py，引入并行处理和循环修复逻辑。Day 5（持续优化）：调整各智能体的 System Prompt，优化 CLAUDE.md 中的项目规范，确保智能体产出的代码符合团队标准。通过这一路径，用户将构建出一个不仅仅是“聊天机器人”集合，而是一个具备感知、决策、执行能力的硅基开发团队。







